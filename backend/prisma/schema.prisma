// ------------------------
// Générateur Prisma Client
// ------------------------
generator client {
  provider = "prisma-client-js"
}

// ------------------------
// Source de données
// ------------------------
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ------------------------
// ENUMS
// ------------------------
enum Role {
  CLIENT
  COIFFEUSE
  VENDEUSE
  ADMIN
}

enum ImageType {
  UPLOADED
  URL
}

enum BookingStatus {
  PENDING
  CONFIRMED
  CANCELLED
  COMPLETED
}

enum OrderStatus {
  PENDING
  PROCESSING
  PAID
  SHIPPED
  DELIVERED
  CANCELLED
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
  REFUNDED
}

// ------------------------
// MODELS
// ------------------------
model User {
  id        String   @id @default(uuid())
  email     String   @unique
  password  String
  role      Role     @default(CLIENT)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  profile          Profile?
  notificationToken NotificationToken?
  orders           Order[]
  products         Product[] @relation("UserProducts") // Pour les vendeuses
  bookings         Booking[] // Pour les clients
  reviews          Review[] // Avis laissés
  payments         Payment[] // Paiements effectués
  conversations1   Conversation[] @relation("Conversations1") // Conversations où l'utilisateur est participant1
  conversations2   Conversation[] @relation("Conversations2") // Conversations où l'utilisateur est participant2
  messages         Message[] // Messages envoyés
}

model Profile {
  id                String    @id @default(uuid())
  userId            String    @unique
  user              User      @relation(fields: [userId], references: [id])
  firstName         String
  lastName          String
  phone             String?
  address           String?
  city              String? // Ville
  postalCode        String? // Code postal
  country           String? // Pays
  avatar            String?
  bio               String? // Biographie
  specialties       String[] // Spécialités (array)
  experience        Int? // Années d'expérience
  website           String? // Site web
  instagram         String? // Instagram
  facebook          String? // Facebook
  tiktok            String? // TikTok
  isProvider        Boolean   @default(false)
  totalBookings     Int       @default(0) // Total réservations
  completedBookings Int       @default(0) // Réservations complétées
  cancellationRate  Float? // Taux d'annulation
  services          Service[]
  portfolio         Image[]
  rating            Float?
}

model Product {
  id                 String      @id @default(uuid())
  name               String
  slug               String      @unique
  description        String
  price              Float
  originalPrice      Float? // Prix original (avant promotion)
  discountPrice      Float? // Prix en promotion
  isOnSale           Boolean     @default(false)
  discountPercentage Int? // Pourcentage de réduction
  brand              String? // Marque du produit
  volume             String? // Volume/contenance (ex: "50ml", "250g")
  ingredients        String? // Liste des ingrédients
  skinType           String? // Type de peau (ex: "Tous types", "Peau sensible")
  sku                String?     @unique // Stock Keeping Unit
  categoryId         String
  category           Category    @relation(fields: [categoryId], references: [id])
  images             Image[]
  stock              Int
  lowStockThreshold  Int? // Seuil d'alerte stock bas
  isActive           Boolean     @default(true)
  isFeatured         Boolean     @default(false)
  views              Int         @default(0)
  salesCount         Int         @default(0)
  averageRating      Float? // Note moyenne calculée
  orders             OrderItem[]
  reviews            Review[]
  sellerId           String
  seller             User        @relation("UserProducts", fields: [sellerId], references: [id])
  createdAt          DateTime    @default(now())
  updatedAt          DateTime    @updatedAt
}

model Service {
  id                 String    @id @default(uuid())
  name               String
  slug               String    @unique
  description        String?
  price              Float
  duration           Int // en minutes
  category           String? // Catégorie de service (ex: "Tresses", "Locks", "Pose perruque")
  available          Boolean   @default(true)
  maxBookingsPerDay  Int? // Nombre max de réservations/jour
  advanceBookingDays Int? // Jours à l'avance pour réserver
  views              Int       @default(0)
  bookingsCount      Int       @default(0)
  averageRating      Float? // Note moyenne calculée
  isFeatured         Boolean   @default(false)
  providerId         String
  provider           Profile   @relation(fields: [providerId], references: [id])
  bookings           Booking[]
  reviews            Review[]
  images             Image[]
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt
}

model Image {
  id          String    @id @default(uuid())
  url         String
  type        ImageType
  alt         String? // Texte alternatif
  title       String? // Titre de l'image
  order       Int? // Ordre d'affichage
  isPrimary   Boolean   @default(false) // Image principale
  productId   String?
  product     Product?  @relation(fields: [productId], references: [id])
  serviceId   String?
  service     Service?  @relation(fields: [serviceId], references: [id])
  portfolioId String?
  portfolio   Profile?  @relation(fields: [portfolioId], references: [id])
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
}

model Category {
  id          String     @id @default(uuid())
  name        String     @unique
  slug        String     @unique
  description String?
  image       String? // Image de la catégorie
  isActive    Boolean    @default(true)
  order       Int? // Ordre d'affichage
  parentId    String? // Catégorie parente (pour sous-catégories)
  parent      Category?  @relation("CategoryHierarchy", fields: [parentId], references: [id])
  children    Category[] @relation("CategoryHierarchy")
  products    Product[]
}

model Order {
  id                    String      @id @default(uuid())
  orderNumber           String      @unique // Numéro de commande unique
  userId                String? // Peut être null pour les commandes guest
  user                  User?       @relation(fields: [userId], references: [id])
  customerEmail         String // Email du client (pour notifications)
  customerName          String // Nom complet du client
  customerPhone         String? // Téléphone du client
  shippingAddress       String // Adresse de livraison
  billingAddress        String? // Adresse de facturation
  shippingMethod        String? // Méthode de livraison
  shippingCost          Float       @default(0) // Coût de livraison
  trackingNumber        String? // Numéro de suivi
  estimatedDeliveryDate DateTime? // Date de livraison estimée
  notes                 String? // Notes de la commande
  cancellationReason    String? // Raison d'annulation
  couponId              String? // Coupon appliqué
  coupon                Coupon?     @relation(fields: [couponId], references: [id])
  subtotal              Float // Sous-total avant réduction
  discount              Float       @default(0) // Montant de la réduction
  total                 Float // Total final
  status                OrderStatus @default(PENDING)
  items                 OrderItem[]
  payment               Payment?
  createdAt             DateTime    @default(now())
  updatedAt             DateTime    @updatedAt
}

model OrderItem {
  id        String  @id @default(uuid())
  orderId   String
  order     Order   @relation(fields: [orderId], references: [id])
  productId String
  product   Product @relation(fields: [productId], references: [id])
  quantity  Int
  price     Float
}

model Booking {
  id                 String        @id @default(uuid())
  bookingNumber      String        @unique // Numéro de réservation unique
  userId             String? // Peut être null pour les réservations guest
  user               User?         @relation(fields: [userId], references: [id])
  serviceId          String
  service            Service       @relation(fields: [serviceId], references: [id])
  date               DateTime // Date du rendez-vous
  startTime          DateTime // Heure de début
  endTime            DateTime // Heure de fin (calculée)
  location           String? // Lieu du rendez-vous
  clientName         String? // Nom complet du client (pour réservations guest)
  clientPhone        String? // Téléphone du client
  clientEmail        String? // Email du client
  status             BookingStatus @default(PENDING)
  notes              String?
  reminderSent       Boolean       @default(false) // Rappel envoyé
  cancellationReason String? // Raison d'annulation
  rescheduleCount    Int           @default(0) // Nombre de reports
  payment            Payment?
  createdAt          DateTime      @default(now())
  updatedAt          DateTime      @updatedAt
}

model Payment {
  id            String        @id @default(uuid())
  amount        Float
  currency      String        @default("EUR") // Devise
  status        PaymentStatus @default(PENDING)
  provider      String // ex: 'stripe', 'mobile_money'
  paymentMethod String? // Méthode (carte, mobile money, etc.)
  transactionId String? // ID externe du paiement
  refundAmount  Float? // Montant remboursé
  refundReason  String? // Raison du remboursement
  userId        String
  user          User          @relation(fields: [userId], references: [id])
  bookingId     String?       @unique
  booking       Booking?      @relation(fields: [bookingId], references: [id])
  orderId       String?       @unique
  order         Order?        @relation(fields: [orderId], references: [id])
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
}

model Review {
  id                 String   @id @default(uuid())
  rating             Int // 1-5
  comment            String?
  isVerifiedPurchase Boolean  @default(false) // Achat vérifié
  isPublished        Boolean  @default(true) // Avis publié
  helpfulCount       Int      @default(0) // Nombre de "utile"
  userId             String
  user               User     @relation(fields: [userId], references: [id])
  productId          String?
  product            Product? @relation(fields: [productId], references: [id])
  serviceId          String?
  service            Service? @relation(fields: [serviceId], references: [id])
  createdAt          DateTime @default(now())
}

model Coupon {
  id            String   @id @default(uuid())
  code          String   @unique // Code du coupon (ex: "WELCOME10")
  description   String? // Description du coupon
  discountType  String // "PERCENTAGE" ou "FIXED"
  discountValue Float // Valeur de la réduction (pourcentage ou montant fixe)
  minPurchase   Float? // Montant minimum d'achat requis
  maxDiscount   Float? // Réduction maximale (pour les pourcentages)
  validFrom     DateTime // Date de début de validité
  validUntil    DateTime // Date de fin de validité
  usageLimit    Int? // Nombre maximum d'utilisations totales
  usageCount    Int      @default(0) // Nombre d'utilisations actuelles
  userLimit     Int? // Nombre maximum d'utilisations par utilisateur
  isActive      Boolean  @default(true) // Coupon actif/inactif
  applicableTo  String? // "ALL", "PRODUCTS", "SERVICES", ou IDs spécifiques
  orders        Order[] // Commandes utilisant ce coupon
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}

model NotificationToken {
  id        String   @id @default(uuid())
  userId    String   @unique
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  token     String   @unique // FCM token
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Conversation {
  id        String    @id @default(uuid())
  participant1Id String
  participant1   User   @relation("Conversations1", fields: [participant1Id], references: [id], onDelete: Cascade)
  participant2Id String
  participant2   User   @relation("Conversations2", fields: [participant2Id], references: [id], onDelete: Cascade)
  lastMessageAt DateTime?
  lastMessage   String?
  unreadCount1  Int     @default(0) // Messages non lus pour participant1
  unreadCount2  Int     @default(0) // Messages non lus pour participant2
  messages      Message[]
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@unique([participant1Id, participant2Id])
  @@index([participant1Id])
  @@index([participant2Id])
}

model Message {
  id             String       @id @default(uuid())
  conversationId String
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  senderId       String
  sender         User         @relation(fields: [senderId], references: [id], onDelete: Cascade)
  content        String
  isRead         Boolean      @default(false)
  createdAt      DateTime     @default(now())

  @@index([conversationId])
  @@index([senderId])
}
